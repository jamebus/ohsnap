#!/bin/sh
#
# ohsnap is a program which makes backups of entire filesystems. If the
# filesystem is on a LVM2 logical volume, a snapshot will be taken and the
# backup taken from that. This is ideal for a busy system.
#
@LICENSE@

set -eu

logfile='/var/log/ohsnap.log'
pidfile='/var/run/ohsnap.pid'
configfile='@SYSCONFDIR@/ohsnap.conf'

logging_cmd="dd oflag=append conv=notrunc of=$logfile"
if [ "${1:-}" = '-v' ]; then
	logging_cmd="tee -a $logfile"
elif [ -n "${1:-}" ]; then
	echo "WARNING: Unknown option given, ignoring." 1>&2
fi

if [ -f "$pidfile" ]; then
	if kill -0 $(cat "$pidfile") >/dev/null; then
		echo 'Another instance is running.' 1>&2
		exit 1
	fi
	echo 'Stale pidfile, clearing.' 1>&2
	rm -f "$pidfile"
fi
echo "$$" > "$pidfile"

if [ ! -f "$logfile" ]; then
	install -m 0640 -o root -g adm /dev/null "$logfile"
elif [ $(date '+%w') -eq 0 ]; then
	savelog -p -t -q -n "$logfile"
fi

(

set -exu
umask 077
unset IFS

. "$configfile"

test -n "$destination"
test -n "$filesystems"

probe_fstype() {
	# Extra tests for $4 and $2 catch possible output changes between
	# mount(8) versions.
	mount | awk -v mp="$1" '
		($3 == mp && $4 == "type" && $2 == "on") {print $5}
	'
}

has_cmd() {
	local rc
	set +e
	which "$1" >/dev/null 2>&1
	rc=$?
	set -e
	return $rc
}

: ${compress:='auto'}
: ${compress_opts:=''}
: ${compress_ext:=''}

case "$compress_opts" in
	[Aa][Uu][Tt][Oo])
		compress_opts=''
		;;
esac

case "$compress_ext" in
	[Aa][Uu][Tt][Oo])
		compress_ext=''
		;;
esac

case "$compress" in
	[Aa][Uu][Tt][Oo])
		compress_opts=''
		compress_ext=''
		if has_cmd xz; then
			compress='xz'
		elif has_cmd lzma; then
			compress='lzma'
		elif has_cmd lzip; then
			compress='lzip'
		elif has_cmd bzip2; then
			compress='bzip2'
		elif has_cmd gzip; then
			compress='gzip'
		elif has_cmd lzop; then
			compress='lzop'
		# I feel sorry for for the person who only has compress(1).
		elif has_cmd compress; then
			compress='compress'
		else
			compress='cat'
		fi
		;;
esac

case "$compress" in
	'xz')
		: ${compress_ext:='xz'}
		: ${compress_opts:='-2'}
		;;
	'lzma')
		: ${compress_ext:='lzma'}
		: ${compress_opts:='-2'}
		;;
	'lzip')
		: ${compress_ext:='lz'}
		: ${compress_opts:='-2'}
		;;
	'bzip2')
		: ${compress_ext:='bz2'}
		: ${compress_opts:='-3'}
		;;
	'gzip')
		: ${compress_ext:='gz'}
		: ${compress_opts:='-4'}
		;;
	'lzop')
		: ${compress_ext:='lzop'}
		: ${compress_opts:='-1'}
		;;
	'compress')
		: ${compress_ext:='Z'}
		;;
	[Nn][Oo][Nn][Ee])
		compress='cat'
		;;
esac

cd "$destination"

if [ ! -d 0 -o $(date '+%w') -eq 0 ]; then
	level=0
else
	level=$(($(cat 0/current_level) + 1))
fi

if [ $level -eq 0 ]; then
	destination_current=$(mktemp -d current.XXXXXXXXXX)
else
	destination_current=0
fi
cd "$destination_current"

df -h > df-h.out
cp /etc/fstab .
test -f /proc/mdstat && cp /proc/mdstat .
for c in pvdisplay vgdisplay lvdisplay; do
	if has_cmd $c; then
		$c > ${c}.out
	fi
done
if has_cmd parted; then
	parted -l > parted.out
fi

: ${snapshot_size:='1g'}
_filesystems=''
for f in $filesystems; do
	IFS=':'
	set -- $f
	unset IFS
	name="$1"
	mp="$2"
	lvpath="${3:-}"
	snaplvpath=''
	fstype=$(probe_fstype "$mp")

	if [ -n "$lvpath" -a "$fstype" != 'btrfs' ]; then
		lvcreate -L "$snapshot_size" -s -n "snap_${name}" "$lvpath"
		mp=$(mktemp -d -t)
		# Is there some dm API / command to do this nicer?
		snaplvpath="/dev/$(echo $lvpath | sed -r 's,^/dev/([^/]+)/.*,\1,')/snap_${name}"
		if [ "$fstype" = 'xfs' ]; then
			mount -o nouuid,ro "$snaplvpath" "$mp"
		else
			mount -o ro "$snaplvpath" "$mp"
		fi
	fi
	if [ "$fstype" = 'btrfs' ]; then
		snap_mp="${mp}/snap_${name}"
		if has_cmd btrfs; then
			btrfs subvolume snapshot "$mp" "$snap_mp"
		else
			btrfsctl -s "$snap_mp" "$mp"
		fi
		mp="$snap_mp"
	fi
	_filesystems="${_filesystems} ${name}:${mp}:${lvpath}:${snaplvpath}"
done
filesystems="$_filesystems"

for f in $filesystems; do
	IFS=':'
	set -- $f
	unset IFS
	name="$1"
	mp="$2"
	lvpath="${3:-}"
	snaplvpath="${4:-}"
	fstype=$(probe_fstype "$mp")
	has_cmd xfs_info && has_xfs_info=1 || has_xfs_info=0
	has_cmd xfsdump &&  has_xfsdump=1  || has_xfsdump=0

	test "$fstype" = 'xfs' -a "$has_xfs_info" -eq 1 && \
	  xfs_info "$mp" > "${name}.xfs_info"

	if [ "$fstype" = 'xfs' -a "$has_xfsdump" -eq 1 ]; then
		xfsdump -L "ohsnap-${name}" -l $level - "$mp" | \
		"$compress" $compress_opts > "${name}.${level}.xfsdump.${compress_ext}"
	else
		tar -V "ohsnap-${name}" --listed-incremental="${name}.snar" \
		--one-file-system -C "$mp" -cvf - . | \
		"$compress" $compress_opts > "${name}.${level}.tar.${compress_ext}"
	fi

	if [ "$fstype" = '' -a \
	     "$(probe_fstype $(dirname "$mp"))" = 'btrfs' ]; then
		if has_cmd btrfs; then
			btrfs subvolume delete "$mp"
		else
			btrfsctl -D $(basename "$mp") $(dirname "$mp")
		fi
	elif [ -n "$snaplvpath" ]; then
		umount "$mp"
		lvremove -f "$snaplvpath"
		rmdir "$mp"
	fi
done

echo "$level" > current_level

: ${cycles:=0}
if [ $level -eq 0 ]; then
	cd ..
	c="$cycles"
	while [ $c -gt -1 ]; do
		test -d $c && mv $c $(($c+1))
		c=$(($c-1))
	done
	rm -rf $(($cycles + 1))
	mv "$destination_current" 0
fi

) 2>&1 | $logging_cmd 2>/dev/null

rm -f "$pidfile"
